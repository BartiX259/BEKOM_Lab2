services:
  # --- SEGMENT CENTRALNY: FW-HQ ---
  fw-hq:
    build:
      context: .
      dockerfile: Dockerfile # Używa głównego Dockerfile (Ubuntu z toolsami)
    container_name: fw-hq
    sysctls:
      - net.ipv4.ip_forward=1
    cap_add:
      - NET_ADMIN
    networks:
      net_internet:
        ipv4_address: 172.20.0.2
      net_yellow:
        ipv4_address: 10.0.10.2
      net_blue:
        ipv4_address: 10.0.20.2
      net_green:
        ipv4_address: 10.0.30.2
      net_red:
        ipv4_address: 10.0.40.2
      net_mgmt:
        ipv4_address: 10.0.99.2
    command: >
      /bin/bash -c "
      chmod +x /opt/firewall_rules.sh &&
      /opt/firewall_rules.sh &&
      tail -f /dev/null
      "
    volumes:
      - ./config/firewall_rules.sh:/opt/firewall_rules.sh
      - ./config/local.rules:/opt/local.rules
      - ./config/start_nids.sh:/opt/start_nids.sh
    ports:
      - "8080:80" # Przekierowanie portu dla dostępu do serwera WWW w segmencie niebieskim

  # --- SEGMENT ŻÓŁTY ---
  # DNS (Tu zostawiamy ubuntu/bind9, bo to specyficzny obraz,
  # ewentualnie można dodać instalację toolsów ręcznie jeśli potrzebne,
  # ale zazwyczaj DNS tylko odpytujemy)
  dns-server:
    image: ubuntu/bind9
    container_name: dns-main
    user: root
    networks:
      net_yellow:
        ipv4_address: 10.0.10.10
    cap_add:
      - NET_ADMIN
    environment:
      - BIND9_USER=root
    volumes:
      - ./config/dns/named.conf.options:/etc/bind/named.conf.options
      - ./logs/dns:/var/log/named
      # Montujemy nasz nowy skrypt:
      - ./config/dns/setup.sh:/opt/setup.sh
    entrypoint: ["/opt/setup.sh"]

  # --- SEGMENT NIEBIESKI ---
  web-server:
    build:
      context: .
      dockerfile: Dockerfile.nginx # <--- Budujemy z naszego pliku dla Nginx
    container_name: web-dmz
    networks:
      net_blue:
        ipv4_address: 10.0.20.10
    cap_add:
      - NET_ADMIN
    command: >
      /bin/bash -c "
      ip route del default &&
      ip route add default via 10.0.20.2 &&
      nginx -g 'daemon off;'
      "
    volumes:
      - ./config/nginx.conf:/etc/nginx/nginx.conf

  # --- SEGMENT ZIELONY ---
  host-green-1:
    build:
      context: .
      dockerfile: Dockerfile # <--- Używa głównego Dockerfile (Ubuntu z toolsami)
    container_name: employee-1
    networks:
      net_green:
        ipv4_address: 10.0.30.10
    cap_add:
      - NET_ADMIN
    command: >
      /bin/bash -c "
      ip route del default &&
      ip route add default via 10.0.30.2 &&
      tail -f /dev/null
      "

  # --- SEGMENT CZERWONY ---
  db-server:
    build:
      context: .
      dockerfile: Dockerfile.db # <--- Budujemy z naszego pliku dla Postgres
    container_name: db-backend
    networks:
      net_red:
        ipv4_address: 10.0.40.10
    cap_add:
      - NET_ADMIN
    environment:
      POSTGRES_PASSWORD: securepass

  # --- SEGMENT MGMT ---
  # Wazuh i Kali są zbyt dużymi obrazami, by je przebudowywać w locie,
  # zazwyczaj mają już narzędzia (Kali ma wszystko, Wazuh ma podstawy).
  siem-wazuh:
    build:
      context: .
      dockerfile: Dockerfile.siem
    image: wazuh/wazuh-manager:4.14.1
    container_name: siem-manager
    networks:
      net_mgmt:
        ipv4_address: 10.0.99.10
    cap_add:
      - NET_ADMIN
    ports:
      - "443:443"
      - "1514:1514"

  scanner:
    build:
      context: .
      dockerfile: Dockerfile.kali
    image: kalilinux/kali-rolling
    container_name: vulnerability-scanner
    networks:
      net_mgmt:
        ipv4_address: 10.0.99.20
    cap_add:
      - NET_ADMIN
    command: tail -f /dev/null

# --- DEFINICJA SIECI (Bez zmian) ---
networks:
  net_internet:
    ipam:
      config:
        - subnet: 172.20.0.0/24
  net_yellow:
    ipam:
      config:
        - subnet: 10.0.10.0/24
  net_blue:
    ipam:
      config:
        - subnet: 10.0.20.0/24
  net_green:
    ipam:
      config:
        - subnet: 10.0.30.0/24
  net_red:
    ipam:
      config:
        - subnet: 10.0.40.0/24
  net_mgmt:
    ipam:
      config:
        - subnet: 10.0.99.0/24
